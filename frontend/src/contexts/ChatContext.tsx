import React, { createContext, useContext, useState, useEffect, useRef, ReactNode } from 'react';
import axios from 'axios';
import { useAuth } from './AuthContext';

interface Message {
  id: string;
  text: string;
  sender: 'user' | 'ai';
  timestamp: Date;
  type: 'text' | 'voice' | 'system';
  metadata?: {
    language?: string;
    confidence?: number;
    audioUrl?: string;
    voice_ready?: string[];
    intent?: string;
    suggestions?: string[];
  };
}

interface ChatContextType {
  messages: Message[];
  isLoading: boolean;
  sendMessage: (text: string, language: string) => Promise<void>;
  clearMessages: () => void;
  isConnected: boolean;
}

const ChatContext = createContext<ChatContextType | undefined>(undefined);

export const useChat = () => {
  const context = useContext(ChatContext);
  if (context === undefined) {
    throw new Error('useChat must be used within a ChatProvider');
  }
  return context;
};

interface ChatProviderProps {
  children: ReactNode;
}

export const ChatProvider: React.FC<ChatProviderProps> = ({ children }) => {
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [isConnected, setIsConnected] = useState(false);
  const wsRef = useRef<WebSocket | null>(null);
  const { user } = useAuth();

  // Mock AI responses for demonstration
  const mockAIResponses = {
    'crop advice': '‡§Ü‡§™‡§ï‡•Ä ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§î‡§∞ ‡§Æ‡•å‡§∏‡§Æ ‡§ï‡•á ‡§Ö‡§®‡•Å‡§∏‡§æ‡§∞, ‡§á‡§∏ ‡§∏‡•Ä‡§ú‡§® ‡§Æ‡•á‡§Ç ‡§ó‡•á‡§π‡•Ç‡§Ç, ‡§∏‡§∞‡§∏‡•ã‡§Ç ‡§Ø‡§æ ‡§ö‡§®‡§æ ‡§ï‡•Ä ‡§ñ‡•á‡§§‡•Ä ‡§Ö‡§ö‡•ç‡§õ‡•Ä ‡§∞‡§π‡•á‡§ó‡•Ä‡•§ ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•ã ‡§µ‡§ø‡§∏‡•ç‡§§‡•É‡§§ ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§¶‡•á ‡§∏‡§ï‡§§‡§æ ‡§π‡•Ç‡§Ç‡•§',
    'loan help': '‡§ï‡•É‡§∑‡§ø ‡§ã‡§£ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Ü‡§™ PM-Kisan ‡§Ø‡•ã‡§ú‡§®‡§æ, KCC ‡§ï‡§æ‡§∞‡•ç‡§° ‡§Ø‡§æ ‡§¨‡•à‡§Ç‡§ï ‡§ã‡§£ ‡§ï‡§æ ‡§≤‡§æ‡§≠ ‡§â‡§†‡§æ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§ ‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§ï‡§ø‡§∏‡•Ä ‡§µ‡§ø‡§∂‡•á‡§∑ ‡§Ø‡•ã‡§ú‡§®‡§æ ‡§ï‡•á ‡§¨‡§æ‡§∞‡•á ‡§Æ‡•á‡§Ç ‡§ú‡§æ‡§®‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç?',
    'market prices': '‡§Ü‡§ú ‡§ï‡•á ‡§Æ‡§Ç‡§°‡•Ä ‡§≠‡§æ‡§µ: ‡§ó‡•á‡§π‡•Ç‡§Ç ‚Çπ2,100-2,300/quintal, ‡§ß‡§æ‡§® ‚Çπ1,800-2,000/quintal, ‡§Æ‡§ï‡•ç‡§ï‡§æ ‚Çπ1,500-1,700/quintal‡•§ ‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§ï‡§ø‡§∏‡•Ä ‡§µ‡§ø‡§∂‡•á‡§∑ ‡§´‡§∏‡§≤ ‡§ï‡§æ ‡§≠‡§æ‡§µ ‡§ú‡§æ‡§®‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç?',
    'risk alert': '‡§Ü‡§™‡§ï‡•á ‡§ï‡•ç‡§∑‡•á‡§§‡•ç‡§∞ ‡§Æ‡•á‡§Ç ‡§Ö‡§ó‡§≤‡•á 3 ‡§¶‡§ø‡§®‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§¨‡§æ‡§∞‡§ø‡§∂ ‡§ï‡•Ä ‡§∏‡§Ç‡§≠‡§æ‡§µ‡§®‡§æ ‡§π‡•à‡•§ ‡§´‡§∏‡§≤ ‡§∏‡•Å‡§∞‡§ï‡•ç‡§∑‡§æ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§â‡§ö‡§ø‡§§ ‡§â‡§™‡§æ‡§Ø ‡§ï‡§∞‡•á‡§Ç‡•§',
    'farming calendar': '‡§á‡§∏ ‡§Æ‡§π‡•Ä‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è: ‡§ó‡•á‡§π‡•Ç‡§Ç ‡§ï‡•Ä ‡§¨‡•Å‡§µ‡§æ‡§à ‡§ï‡§æ ‡§∏‡§π‡•Ä ‡§∏‡§Æ‡§Ø ‡§π‡•à, ‡§∏‡§∞‡§∏‡•ã‡§Ç ‡§ï‡•Ä ‡§ï‡§ü‡§æ‡§à ‡§ï‡§∞‡•á‡§Ç, ‡§î‡§∞ ‡§®‡§à ‡§´‡§∏‡§≤‡•ã‡§Ç ‡§ï‡•Ä ‡§Ø‡•ã‡§ú‡§®‡§æ ‡§¨‡§®‡§æ‡§è‡§Ç‡•§',
    'local schemes': '‡§Ü‡§™‡§ï‡•á ‡§∞‡§æ‡§ú‡•ç‡§Ø ‡§Æ‡•á‡§Ç ‡§ï‡§à ‡§∏‡§∞‡§ï‡§æ‡§∞‡•Ä ‡§Ø‡•ã‡§ú‡§®‡§æ‡§è‡§Ç ‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§π‡•à‡§Ç: ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§∏‡•ç‡§µ‡§æ‡§∏‡•ç‡§•‡•ç‡§Ø ‡§ï‡§æ‡§∞‡•ç‡§°, ‡§´‡§∏‡§≤ ‡§¨‡•Ä‡§Æ‡§æ, ‡§î‡§∞ ‡§∏‡§¨‡•ç‡§∏‡§ø‡§°‡•Ä‡•§ ‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§ï‡§ø‡§∏‡•Ä ‡§µ‡§ø‡§∂‡•á‡§∑ ‡§Ø‡•ã‡§ú‡§®‡§æ ‡§ï‡•á ‡§¨‡§æ‡§∞‡•á ‡§Æ‡•á‡§Ç ‡§ú‡§æ‡§®‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç?'
  };

  useEffect(() => {
    // Add welcome message when component mounts
    addMessage({
      id: Date.now().toString(),
      text: `‡§®‡§Æ‡§∏‡•ç‡§§‡•á ${user?.name || '‡§ï‡§ø‡§∏‡§æ‡§®'}! ‡§Æ‡•à‡§Ç KrishiMitra ‡§Ü‡§™‡§ï‡•Ä ‡§ï‡•à‡§∏‡•á ‡§Æ‡§¶‡§¶ ‡§ï‡§∞ ‡§∏‡§ï‡§§‡§æ ‡§π‡•Ç‡§Ç? ‡§¨‡•ã‡§≤‡§ï‡§∞ ‡§Ö‡§™‡§®‡§æ ‡§∏‡§µ‡§æ‡§≤ ‡§™‡•Ç‡§õ‡•á‡§Ç - ‡§´‡§∏‡§≤, ‡§ã‡§£, ‡§Æ‡§Ç‡§°‡•Ä ‡§≠‡§æ‡§µ, ‡§Æ‡•å‡§∏‡§Æ ‡§Ø‡§æ ‡§∏‡§∞‡§ï‡§æ‡§∞‡•Ä ‡§Ø‡•ã‡§ú‡§®‡§æ‡§ì‡§Ç ‡§ï‡•á ‡§¨‡§æ‡§∞‡•á ‡§Æ‡•á‡§Ç‡•§`,
      sender: 'ai',
      timestamp: new Date(),
      type: 'system',
      metadata: {
        voice_ready: [`‡§®‡§Æ‡§∏‡•ç‡§§‡•á ${user?.name || '‡§ï‡§ø‡§∏‡§æ‡§®'}! ‡§Æ‡•à‡§Ç KrishiMitra ‡§Ü‡§™‡§ï‡•Ä ‡§ï‡•à‡§∏‡•á ‡§Æ‡§¶‡§¶ ‡§ï‡§∞ ‡§∏‡§ï‡§§‡§æ ‡§π‡•Ç‡§Ç?`, "‡§¨‡•ã‡§≤‡§ï‡§∞ ‡§Ö‡§™‡§®‡§æ ‡§∏‡§µ‡§æ‡§≤ ‡§™‡•Ç‡§õ‡•á‡§Ç - ‡§´‡§∏‡§≤, ‡§ã‡§£, ‡§Æ‡§Ç‡§°‡•Ä ‡§≠‡§æ‡§µ, ‡§Æ‡•å‡§∏‡§Æ ‡§Ø‡§æ ‡§∏‡§∞‡§ï‡§æ‡§∞‡•Ä ‡§Ø‡•ã‡§ú‡§®‡§æ‡§ì‡§Ç ‡§ï‡•á ‡§¨‡§æ‡§∞‡•á ‡§Æ‡•á‡§Ç‡•§"],
        intent: 'welcome',
        suggestions: ['‡§´‡§∏‡§≤ ‡§ï‡•Ä ‡§∏‡§≤‡§æ‡§π ‡§≤‡•á‡§Ç', '‡§ã‡§£ ‡§ï‡•Ä ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§≤‡•á‡§Ç', '‡§Æ‡§Ç‡§°‡•Ä ‡§≠‡§æ‡§µ ‡§ú‡§æ‡§®‡•á‡§Ç', '‡§Æ‡•å‡§∏‡§Æ ‡§ï‡•Ä ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§≤‡•á‡§Ç']
      }
    });
  }, []); // Only run once on mount

  useEffect(() => {
    // Only try to connect if we have a user or are in anonymous mode
    if (user || true) { // Always try to connect, even anonymously
      console.log('Attempting WebSocket connection...');
      connectWebSocket();
    } else {
      console.log('No user available, using mock responses');
    }

    return () => {
      console.log('Cleaning up WebSocket connection...');
      if (wsRef.current) {
        // Only close if the connection is actually open or connecting
        if (wsRef.current.readyState === WebSocket.OPEN || wsRef.current.readyState === WebSocket.CONNECTING) {
          wsRef.current.close(1000, 'Component unmounting');
        }
      }
    };
  }, []); // Remove user dependency to prevent reconnection loops

  const connectWebSocket = () => {
    try {
      // Close existing connection if any
      if (wsRef.current) {
        if (wsRef.current.readyState === WebSocket.OPEN || wsRef.current.readyState === WebSocket.CONNECTING) {
          console.log('Closing existing WebSocket connection...');
          wsRef.current.close(1000, 'Reconnecting');
        }
      }

      const wsUrl = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/ws';
      const clientId = user?.id || 'anonymous';
      
      console.log(`Connecting to WebSocket: ${wsUrl}/${clientId}`);
      wsRef.current = new WebSocket(`${wsUrl}/${clientId}`);
      
      wsRef.current.onopen = () => {
        console.log('‚úÖ WebSocket connected successfully');
        setIsConnected(true);
      };
      
      wsRef.current.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          console.log('üì® WebSocket message received:', data);
          handleWebSocketMessage(data);
        } catch (error) {
          console.error('‚ùå Error parsing WebSocket message:', error);
        }
      };
      
      wsRef.current.onclose = (event) => {
        console.log(`üîå WebSocket disconnected - Code: ${event.code}, Reason: ${event.reason}`);
        setIsConnected(false);
        
        // Only attempt to reconnect if it wasn't a clean close
        if (event.code !== 1000) {
          console.log('üîÑ Attempting to reconnect in 3 seconds...');
          setTimeout(() => {
            if (wsRef.current?.readyState === WebSocket.CLOSED) {
              connectWebSocket();
            }
          }, 3000);
        }
      };
      
      wsRef.current.onerror = (error) => {
        console.error('‚ùå WebSocket error:', error);
        setIsConnected(false);
      };
    } catch (error) {
      console.error('‚ùå Error connecting to WebSocket:', error);
      setIsConnected(false);
    }
  };

  const handleWebSocketMessage = (data: any) => {
    // Handle KrishiMitra response format
    if (data.text) {
      addMessage({
        id: Date.now().toString(),
        text: data.text,
        sender: 'ai',
        timestamp: new Date(),
        type: 'text',
        metadata: {
          language: data.language,
          confidence: data.confidence,
          voice_ready: data.voice_ready,
          intent: data.intent,
          suggestions: data.suggestions
        }
      });
    } else if (data.type === 'error') {
      addMessage({
        id: Date.now().toString(),
        text: '‡§Æ‡§æ‡§´‡§º ‡§ï‡§∞‡•á‡§Ç, ‡§ï‡•Å‡§õ ‡§ó‡§≤‡§§ ‡§π‡•ã ‡§ó‡§Ø‡§æ‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§´‡§ø‡§∞ ‡§∏‡•á ‡§ï‡•ã‡§∂‡§ø‡§∂ ‡§ï‡§∞‡•á‡§Ç‡•§',
        sender: 'ai',
        timestamp: new Date(),
        type: 'system'
      });
    }
  };

  const addMessage = (message: Message) => {
    setMessages(prev => [...prev, message]);
  };

  const sendMessage = async (text: string, language: string) => {
    if (!text.trim()) return;

    const userMessage: Message = {
      id: Date.now().toString(),
      text,
      sender: 'user',
      timestamp: new Date(),
      type: 'text',
      metadata: { language }
    };

    addMessage(userMessage);
    setIsLoading(true);

    try {
      // Try WebSocket first if available
      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
        wsRef.current.send(JSON.stringify({
          message: text,
          language,
          user_id: user?.id
        }));
      } else {
        // Fallback to mock responses
        await sendMockResponse(text, language);
      }
    } catch (error) {
      console.error('Error sending message:', error);
      
      // Add error message
      addMessage({
        id: (Date.now() + 1).toString(),
        text: '‡§Æ‡§æ‡§´‡§º ‡§ï‡§∞‡•á‡§Ç, ‡§ï‡•Å‡§õ ‡§ó‡§≤‡§§ ‡§π‡•ã ‡§ó‡§Ø‡§æ‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§´‡§ø‡§∞ ‡§∏‡•á ‡§ï‡•ã‡§∂‡§ø‡§∂ ‡§ï‡§∞‡•á‡§Ç‡•§',
        sender: 'ai',
        timestamp: new Date(),
        type: 'system'
      });
    } finally {
      setIsLoading(false);
    }
  };

  const sendMockResponse = async (text: string, language: string) => {
    // Simulate KrishiMitra processing delay
    await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));
    
    // Generate contextual response
    let response = '';
    const lowerText = text.toLowerCase();
    
    if (lowerText.includes('crop') || lowerText.includes('‡§´‡§∏‡§≤')) {
      response = mockAIResponses['crop advice'];
    } else if (lowerText.includes('loan') || lowerText.includes('‡§ã‡§£') || lowerText.includes('‡§ï‡§∞‡•ç‡§ú')) {
      response = mockAIResponses['loan help'];
    } else if (lowerText.includes('market') || lowerText.includes('‡§Æ‡§Ç‡§°‡•Ä') || lowerText.includes('‡§≠‡§æ‡§µ')) {
      response = mockAIResponses['market prices'];
    } else if (lowerText.includes('risk') || lowerText.includes('‡§ú‡•ã‡§ñ‡§ø‡§Æ') || lowerText.includes('‡§Æ‡•å‡§∏‡§Æ')) {
      response = mockAIResponses['risk alert'];
    } else if (lowerText.includes('calendar') || lowerText.includes('‡§ï‡•à‡§≤‡•á‡§Ç‡§°‡§∞')) {
      response = mockAIResponses['farming calendar'];
    } else if (lowerText.includes('scheme') || lowerText.includes('‡§Ø‡•ã‡§ú‡§®‡§æ')) {
      response = mockAIResponses['local schemes'];
    } else {
      // Generic response
      response = '‡§Ü‡§™‡§ï‡§æ ‡§∏‡§µ‡§æ‡§≤ ‡§¨‡§π‡•Å‡§§ ‡§Ö‡§ö‡•ç‡§õ‡§æ ‡§π‡•à! ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§Æ‡§¶‡§¶ ‡§ï‡§∞‡§®‡•á ‡§ï‡•Ä ‡§ï‡•ã‡§∂‡§ø‡§∂ ‡§ï‡§∞‡•Ç‡§Ç‡§ó‡§æ‡•§ ‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§ï‡§ø‡§∏‡•Ä ‡§µ‡§ø‡§∂‡•á‡§∑ ‡§µ‡§ø‡§∑‡§Ø ‡§ï‡•á ‡§¨‡§æ‡§∞‡•á ‡§Æ‡•á‡§Ç ‡§ú‡§æ‡§®‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç?';
    }
    
    addMessage({
      id: Date.now().toString(),
      text: response,
      sender: 'ai',
      timestamp: new Date(),
      type: 'text',
      metadata: { language }
    });
  };

  const sendMessageViaAPI = async (text: string, language: string) => {
    try {
      const response = await axios.post(`${process.env.REACT_APP_API_URL}/api/v1/chat/send`, {
        message: text,
        language,
        user_id: user?.id
      });
      
      if (response.data.success) {
        addMessage({
          id: Date.now().toString(),
          text: response.data.response,
          sender: 'ai',
          timestamp: new Date(),
          type: 'text',
          metadata: { language }
        });
      }
    } catch (error) {
      console.error('API call failed:', error);
      throw error;
    }
  };

  const clearMessages = () => {
    setMessages([]);
  };

  const value: ChatContextType = {
    messages,
    isLoading,
    sendMessage,
    clearMessages,
    isConnected
  };

  return (
    <ChatContext.Provider value={value}>
      {children}
    </ChatContext.Provider>
  );
};
